// script.js (Ïä§ÌÅ¨Î°§ Í∏∞Îä• Ï∂îÍ∞ÄÎêú Ï†ÑÏ≤¥ ÏΩîÎìú)

window.onerror = function (message, source, lineno, colno, error) {
    console.error("üö® Ï†ÑÏó≠ Ïò§Î•ò Î∞úÏÉù:", message, "\nÌååÏùº:", source, `\nÎùºÏù∏:${lineno}:${colno}`, "\nÏò§Î•ò Í∞ùÏ≤¥:", error);
    alert(`Ïïó! ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏñ¥Ïöî üò¢ ÏΩòÏÜî(F12)ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.\nÏò§Î•ò: ${message}`);
};

document.addEventListener('DOMContentLoaded', () => {
    console.log("DEBUG: ÏÉÅÌÉú Î≥ÄÏàò Ï†ïÏùò ÏãúÏûë");
    const PRIMARY_DATA_KEY = 'mtbcTrackerData_v1_1';
    const APP_VERSION = "1.1";
    let chartInstance = null;
    let measurements = [];
    let targets = {};
    let notes = [];
    let currentNoteSortOrder = 'newest';
    let selectedMetrics = ['weight'];

    // ----- Ïä§ÌÅ¨Î°§ Í¥ÄÎ†® Î≥ÄÏàò ÏÑ†Ïñ∏ ÏãúÏûë -----
    let lastScrollY = window.scrollY;
    let isTabBarCollapsed = false; // ÌòÑÏû¨ ÌÉ≠ Î∞î Ï∂ïÏÜå ÏÉÅÌÉú
    // ----- Ïä§ÌÅ¨Î°§ Í¥ÄÎ†® Î≥ÄÏàò ÏÑ†Ïñ∏ ÎÅù -----

    console.log("DEBUG: ÏÉÅÌÉú Î≥ÄÏàò Ï†ïÏùò ÏôÑÎ£å");


    console.log("DEBUG: DOM ÏöîÏÜå Í∞ÄÏ†∏Ïò§Í∏∞ ÏãúÏûë");
    const mainTitle = document.querySelector('#main-title');
    const tabBar = document.querySelector('.tab-bar');
    const tabContents = document.querySelectorAll('.tab-content');
    const form = document.getElementById('measurement-form');
    const formTitle = document.getElementById('form-title');
    const saveUpdateBtn = document.getElementById('save-update-button');
    const cancelEditBtn = document.getElementById('cancel-edit-button');
    const editIndexInput = document.getElementById('edit-index');
    const currentWeekSpan = document.getElementById('current-week');
    const historyContainer = document.getElementById('history-table-container');
    const prevWeekComparisonContainer = document.getElementById('prev-week-comparison-container');
    const initialComparisonContainer = document.getElementById('initial-comparison-container');
    const targetComparisonContainer = document.getElementById('target-comparison-container');
    const calendarViewMeasurementList = document.getElementById('measurement-date-list');
    const countdownDisplay = document.getElementById('countdown-display');
    const chartCanvas = document.getElementById('measurement-chart');
    const chartSelector = document.getElementById('chart-selector');
    const selectAllChartsBtn = document.getElementById('select-all-charts');
    const deselectAllChartsBtn = document.getElementById('deselect-all-charts');
    const resetDataButton = document.getElementById('reset-data-button');
    const exportDataButton = document.getElementById('export-data-button');
    const importDataButton = document.getElementById('import-data-button');
    const importFileInput = document.getElementById('import-file-input');
    const targetForm = document.getElementById('target-form');
    let targetGrid; if (targetForm) { targetGrid = targetForm.querySelector('.target-grid'); }
    const saveTargetsButton = document.getElementById('save-targets-button');
    const noteFormArea = document.getElementById('note-form-area');
    const noteTitleInput = document.getElementById('note-title');
    const noteContentInput = document.getElementById('note-content');
    const saveNoteButton = document.getElementById('save-note-button');
    const noteSortOrderSelect = document.getElementById('note-sort-order');
    const notesListContainer = document.getElementById('notes-list-container');
    const noteFormTitle = document.getElementById('note-form-title');
    const editNoteIdInput = document.getElementById('edit-note-id');
    const cancelEditNoteBtn = document.getElementById('cancel-edit-note-button');
    const savePopup = document.getElementById('save-popup');
    console.log("DEBUG: DOM ÏöîÏÜå Í∞ÄÏ†∏Ïò§Í∏∞ ÏôÑÎ£å");

    console.log("DEBUG: ÏÉÅÏàò Ï†ïÏùò ÏãúÏûë");
    const baseNumericKeys = ['weight', 'shoulder', 'neck', 'chest', 'waist', 'hips', 'thigh', 'calf', 'arm'];
    const hormoneKeys = ['estradiol', 'progesterone'];
    const libidoKey = ['libido'];
    const statusScoreKeys = ['semen_score', 'health_score'];
    const statusNotesKeys = ['semen_notes', 'health_notes'];
    const numericKeys = [...baseNumericKeys, ...hormoneKeys, ...libidoKey, ...statusScoreKeys];
    const textKeys = [...statusNotesKeys];
    const displayKeysInOrder = ['weight', 'shoulder', 'neck', 'chest', 'waist', 'hips', 'thigh', 'calf', 'arm', 'estradiol', 'progesterone', 'libido', 'semen_score', 'semen_notes', 'health_score', 'health_notes'];
    const measurementLabels = {
        week: 'Ï£ºÏ∞®', date: 'ÎÇ†Ïßú', weight: 'Ï≤¥Ï§ë (kg)', shoulder: 'Ïñ¥Íπ®ÎÑàÎπÑ (cm)', neck: 'Î™©ÎëòÎ†à (cm)',
        chest: 'Í∞ÄÏä¥ÎëòÎ†à (cm)', waist: 'ÌóàÎ¶¨ÎëòÎ†à (cm)', hips: 'ÏóâÎç©Ïù¥ÎëòÎ†à (cm)', thigh: 'ÌóàÎ≤ÖÏßÄÎëòÎ†à (cm)', calf: 'Ï¢ÖÏïÑÎ¶¨ÎëòÎ†à (cm)',
        arm: 'ÌåîÎöùÎëòÎ†à (cm)', estradiol: 'ÏóêÏä§Ìä∏ÎùºÎîîÏò¨ (mg)', progesterone: 'ÌîÑÎ°úÍ≤åÏä§ÌÖåÎ°† (mg)', libido: 'ÏÑ±Ïöï (Ìöå/Ï£º)',
        semen_score: 'Ï†ïÏï° ÏÉÅÌÉú Ï†êÏàò', semen_notes: 'Ï†ïÏï° ÏÉÅÌÉú Î©îÎ™®', health_score: 'Í±¥Í∞ï ÏÉÅÌÉú Ï†êÏàò', health_notes: 'Í±¥Í∞ï ÏÉÅÌÉú Î©îÎ™®'
    };
    console.log("DEBUG: ÏÉÅÏàò Ï†ïÏùò ÏôÑÎ£å");

    console.log("DEBUG: Ìï®Ïàò Ï†ïÏùò ÏãúÏûë");

    function formatValue(value) {
        if (typeof value === 'number') {
            return Number.isInteger(value) ? value.toLocaleString() : value.toLocaleString(undefined, { maximumFractionDigits: 1 });
        }
        return value || '-';
    }

    function formatTimestamp(dateInput) {
        if (!dateInput) return 'N/A';
        let date;
        if (typeof dateInput === 'number') {
            date = new Date(dateInput);
        } else {
            // Handle cases like "YYYY.MM.DD"
             const parts = typeof dateInput === 'string' ? dateInput.match(/(\d{4})\.*? *(\d{1,2})\.*? *(\d{1,2})\.?/) : null;
             if (parts) {
                 date = new Date(parseInt(parts[1]), parseInt(parts[2]) - 1, parseInt(parts[3]));
             } else {
                 date = new Date(dateInput); // Fallback for standard parsing
             }
        }

        if (isNaN(date.getTime())) return "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå";

        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        // Check if time is midnight (00:00) - often means time wasn't recorded
        if (hours === '00' && minutes === '00' && dateInput.toString().indexOf(':') === -1) {
             return `${year}-${month}-${day}`; // Only return date if time seems default/absent
        }
        return `${year}-${month}-${day} ${hours}:${minutes}`;
    }


    function showPopup(message, duration = 2000) {
        if (!savePopup) {
            console.error("DEBUG: [Ïò§Î•ò!] Popup ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
            alert(message);
            return;
        }
        console.log(`DEBUG: ÌåùÏóÖ ÌëúÏãú: "${message}"`);
        savePopup.textContent = message;
        savePopup.classList.add('show');
        if (savePopup.timerId) {
            clearTimeout(savePopup.timerId);
        }

        savePopup.timerId = setTimeout(() => {
            savePopup.classList.remove('show');
            console.log(`DEBUG: ÌåùÏóÖ Ïà®ÍπÄ: "${message}"`);
            savePopup.timerId = null;
        }, duration);
    }


    function setupTargetInputs() {
        if (!targetGrid) return;
        targetGrid.innerHTML = '';
        for (const key of displayKeysInOrder) {
            if (numericKeys.includes(key)) {
                const div = document.createElement('div');
                div.classList.add('form-group');
                div.innerHTML = `<label for="target_${key}">${measurementLabels[key]}</label><input type="number" id="target_${key}" name="${key}" step="0.1" min="0">`;
                targetGrid.appendChild(div);
            }
        }
        console.log("DEBUG: Î™©Ìëú ÏûÖÎ†• ÌïÑÎìú ÏÑ§Ï†ï ÏôÑÎ£å");
    }

    function populateTargetInputs() {
        console.log("DEBUG: populateTargetInputs Ìò∏Ï∂úÎê®");
        if (!targetGrid) return;
        for (const key of numericKeys) {
            const input = document.getElementById(`target_${key}`);
            if (input) {
                input.value = targets[key] !== undefined && targets[key] !== null ? targets[key] : '';
            }
        }
        console.log("DEBUG: Î™©Ìëú ÏûÖÎ†• ÌïÑÎìúÏóê Îç∞Ïù¥ÌÑ∞ Ï±ÑÏö∞Í∏∞ ÏôÑÎ£å");
    }

    function savePrimaryDataToStorage() {
        try {
            const dataToSave = {
                measurements: measurements,
                targets: targets,
                notes: notes
            };
            localStorage.setItem(PRIMARY_DATA_KEY, JSON.stringify(dataToSave));
            console.log("DEBUG: Îç∞Ïù¥ÌÑ∞Í∞Ä Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.");
        } catch (e) {
            console.error(" Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû• Ïò§Î•ò:", e);
            alert("Îç∞Ïù¥ÌÑ∞Î•º Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Ï†ÄÏû•ÌïòÎäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
        }
    }

    function loadAllData() {
        try {
            const storedData = localStorage.getItem(PRIMARY_DATA_KEY);
            if (storedData) {
                const data = JSON.parse(storedData);
                measurements = Array.isArray(data.measurements) ? data.measurements : [];
                targets = typeof data.targets === 'object' && data.targets !== null ? data.targets : {};
                notes = Array.isArray(data.notes) ? data.notes : [];
                measurements.forEach((m, index) => m.week = index); // Ensure week index is correct
                console.log("DEBUG: Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìúÎê®:", measurements.length, "Ï∏°Ï†ïÍ∞í,", Object.keys(targets).length, "Î™©Ìëú,", notes.length, "Î©îÎ™®.");
            } else {
                console.log("DEBUG: Ïä§ÌÜ†Î¶¨ÏßÄÏóê Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå. Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§.");
                measurements = []; targets = {}; notes = [];
            }
        } catch (e) {
            console.error(" Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïò§Î•ò:", e);
            alert("Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìúÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÜêÏÉÅÎêòÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§. ÏΩòÏÜîÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
            measurements = []; targets = {}; notes = []; // Reset on error
        }
    }

    function exportMeasurementData() {
        console.log("DEBUG: Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏãúÏûë");
        try {
            const dataToExport = {
                project: "mtbc_tracker", version: APP_VERSION, exportedDate: new Date().toISOString(),
                measurements: measurements, targets: targets, notes: notes
            };
            const dataStr = JSON.stringify(dataToExport, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            const date = new Date();
            const dateStr = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}_${date.getHours().toString().padStart(2, '0')}${date.getMinutes().toString().padStart(2, '0')}`;
            a.href = url;
            a.download = `mtbc_tracker_backup_${dateStr}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showPopup("Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏÑ±Í≥µ! üéâ");
        } catch (e) {
            console.error(" Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïò§Î•ò:", e);
            alert("Îç∞Ïù¥ÌÑ∞Î•º ÎÇ¥Î≥¥ÎÇ¥Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
        }
    }

    function importMeasurementData(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const data = JSON.parse(e.target.result);
                // Basic validation
                if (data && data.project === "mtbc_tracker" && Array.isArray(data.measurements) && typeof data.targets === 'object' && Array.isArray(data.notes)) {
                    if (confirm("ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞Î•º ÎçÆÏñ¥Ïì∞Í≥† Í∞ÄÏ†∏Ïò® Îç∞Ïù¥ÌÑ∞Î°ú Î≥µÏõêÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.")) {
                        measurements = data.measurements || [];
                        targets = data.targets || {};
                        notes = data.notes || [];
                        measurements.forEach((m, index) => m.week = index); // Re-index weeks
                        savePrimaryDataToStorage();
                        populateTargetInputs();
                        renderAll();
                        showPopup("Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ ÏÑ±Í≥µ! ‚ú®");
                        // Optional: reload page if needed for complex state updates, but usually renderAll is enough
                        // location.reload();
                        // alert("Îç∞Ïù¥ÌÑ∞Î•º ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÍ∞Ä ÏÉàÎ°úÍ≥†Ïπ®Îê† Ïàò ÏûàÏäµÎãàÎã§.");
                    }
                } else {
                    alert("ÌååÏùº ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÍ±∞ÎÇò Ìò∏ÌôòÎêòÏßÄ ÏïäÎäî Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§.");
                }
            } catch (e) {
                console.error(" Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Ïò§Î•ò:", e);
                alert("ÌååÏùºÏùÑ ÏùΩÍ±∞ÎÇò Îç∞Ïù¥ÌÑ∞Î•º Ï≤òÎ¶¨ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
            } finally {
                if (importFileInput) importFileInput.value = ''; // Reset file input
            }
        };
        reader.onerror = function () {
            alert("ÌååÏùºÏùÑ ÏùΩÎäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
            if (importFileInput) importFileInput.value = '';
        };
        reader.readAsText(file);
    }

    function updateCurrentWeekDisplay() {
        if (currentWeekSpan) {
            currentWeekSpan.textContent = measurements.length > 0 ? measurements.length : 0;
        } else { console.error("DEBUG: [Ïò§Î•ò!] currentWeekSpan ÏöîÏÜå ÏóÜÏùå!"); }
    }

    function clearTable(container, message = "Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥Ïöî.") {
        if (container) {
            container.innerHTML = `<p style="text-align: center; padding: 20px; color: #a89cc8;">${message}</p>`;
        } else {
            console.error("DEBUG: [Ïò§Î•ò!] clearTable - container ÏöîÏÜåÍ∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
        }
    }

    function clearHistoryTable() {
        console.log("DEBUG: -> clearHistoryTable Ìò∏Ï∂úÎê®");
        clearTable(historyContainer, "Ï∏°Ï†ï Í∏∞Î°ùÏù¥ ÏóÜÏñ¥Ïöî.");
    }

    function clearNotesList() {
        console.log("DEBUG: -> clearNotesList Ìò∏Ï∂úÎê®");
        clearTable(notesListContainer, "ÏûëÏÑ±Îêú Î©îÎ™®Í∞Ä ÏóÜÏñ¥Ïöî.");
    }

    function clearCalendarView() {
        console.log("DEBUG: -> clearCalendarView Ìò∏Ï∂úÎê®");
        if (calendarViewMeasurementList) {
            calendarViewMeasurementList.innerHTML = '';
        }
        if (countdownDisplay) {
             countdownDisplay.innerHTML = '<p>Ï∏°Ï†ï Í∏∞Î°ùÏù¥ ÏóÜÏñ¥Ïöî.</p>';
        }
    }

    function clearChart() {
        console.log("DEBUG: -> clearChart Ìò∏Ï∂úÎê®");
        if (chartInstance) {
            console.log("DEBUG: Í∏∞Ï°¥ Ï∞®Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ Ï†úÍ±∞");
            chartInstance.destroy();
            chartInstance = null;
        }
        if (chartCanvas) {
            const ctx = chartCanvas.getContext('2d');
            if(ctx){
                 ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                 ctx.font = "16px sans-serif";
                 ctx.fillStyle = "#a89cc8";
                 ctx.textAlign = "center";
                 ctx.fillText("ÌëúÏãúÌï† Ìï≠Î™©ÏùÑ ÏÑ†ÌÉùÌïòÍ±∞ÎÇò Îç∞Ïù¥ÌÑ∞Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.", chartCanvas.width / 2, chartCanvas.height / 2);
             }
        }
    }


   function renderHistoryTable() {
    console.log("DEBUG: -> renderHistoryTable Ìò∏Ï∂úÎê®");
    if (!historyContainer) { console.error("DEBUG: [Ïò§Î•ò!] historyContainer ÏöîÏÜå ÏóÜÏùå!"); return; }
    console.log("DEBUG: renderHistoryTable - Rendering with measurements count:", measurements.length);
    if (!Array.isArray(measurements) || measurements.length === 0) {
        clearHistoryTable();
        return;
    }

    try {
        let tableHTML = '<table><thead><tr>';
        tableHTML += `<th>${measurementLabels['week']}</th>`;
        tableHTML += `<th>${measurementLabels['date']}</th>`;
        for (const key of displayKeysInOrder) {
            tableHTML += `<th>${measurementLabels[key] || key}</th>`;
        }
        tableHTML += '<th class="sticky-col">Í¥ÄÎ¶¨</th></tr></thead><tbody>';
        for (let i = 0; i < measurements.length; i++) {
            const m = measurements[i];
            const displayDate = formatTimestamp(m.date || m.timestamp); // Use formatTimestamp for consistency
            tableHTML += '<tr>';
            tableHTML += `<td>${m.week !== undefined ? m.week : i}</td>`;
            tableHTML += `<td>${displayDate}</td>`;
            for (const key of displayKeysInOrder) {
                tableHTML += `<td>${formatValue(m[key])}</td>`;
            }
            tableHTML += `<td class="action-buttons sticky-col">
                            <button class="btn btn-edit" data-index="${i}">ÏàòÏ†ï</button>
                            <button class="btn btn-delete" data-index="${i}">ÏÇ≠Ï†ú</button>
                           </td>`;
            tableHTML += '</tr>';
        }
        tableHTML += '</tbody></table>';
        historyContainer.innerHTML = tableHTML;
        console.log("DEBUG: <- renderHistoryTable ÏôÑÎ£å");
    } catch (e) {
        console.error(" renderHistoryTable Ïò§Î•ò:", e);
        historyContainer.innerHTML = '<p style="color: red;">Í∏∞Î°ù ÌÖåÏù¥Î∏î Î†åÎçîÎßÅ Ï§ë Ïò§Î•ò Î∞úÏÉù</p>';
    }
}

    function renderPrevWeekComparisonTable() {
        if (!prevWeekComparisonContainer) return;
        if (measurements.length < 2) {
            clearTable(prevWeekComparisonContainer, "ÎπÑÍµêÌï† Ïù¥Ï†Ñ Ï£º Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï¥Ïöî.");
            return;
        }
        const lastWeek = measurements[measurements.length - 1];
        const secondLastWeek = measurements[measurements.length - 2];

        let tableHTML = '<table><thead><tr><th>Ï∏°Ï†ï Ìï≠Î™©</th><th>ÏµúÍ∑º Ï£º</th><th>Ïù¥Ï†Ñ Ï£º</th><th>Î≥ÄÌôîÎüâ</th></tr></thead><tbody>';
        for (const key of displayKeysInOrder) {
            if (numericKeys.includes(key)) {
                const lastValue = parseFloat(lastWeek[key]);
                const secondLastValue = parseFloat(secondLastWeek[key]);
                let change = '-'; let changeClass = '';
                if (!isNaN(lastValue) && !isNaN(secondLastValue)) {
                    const diff = lastValue - secondLastValue;
                    change = diff.toFixed(1);
                    if (diff > 0.05) { change = `+${change}`; changeClass = 'positive-change'; }
                    else if (diff < -0.05) { changeClass = 'negative-change'; }
                } else if (!isNaN(lastValue) && isNaN(secondLastValue)) {
                    change = `${formatValue(lastValue)}`;
                    changeClass = ''; // Or maybe positive? Depends on context.
                } else if (isNaN(lastValue) && !isNaN(secondLastValue)){
                    change = `-${formatValue(secondLastValue)}`; // Indicate value loss
                    changeClass = ''; // Or maybe negative?
                }

                tableHTML += `<tr><td>${measurementLabels[key]}</td><td>${formatValue(lastValue)}</td><td>${formatValue(secondLastValue)}</td><td class="${changeClass}">${change}</td></tr>`;
            }
        }
        tableHTML += '</tbody></table>';
        prevWeekComparisonContainer.innerHTML = tableHTML;
    }

    function renderInitialComparisonTable() {
        if (!initialComparisonContainer) return;
        if (measurements.length < 1) {
             clearTable(initialComparisonContainer, "Ï∏°Ï†ï Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥Ïöî.");
             return;
        }
        const initial = measurements[0];
        const latest = measurements[measurements.length - 1];
        const isOnlyOneRecord = measurements.length === 1;

        const initialDateStr = formatTimestamp(initial.date || initial.timestamp).split(' ')[0]; // Date only
        const latestDateStr = formatTimestamp(latest.date || latest.timestamp).split(' ')[0]; // Date only

        let tableHTML = `<table><thead><tr><th>Ï∏°Ï†ï Ìï≠Î™©</th><th>Ï≤òÏùå (${initialDateStr || '-'})</th><th>ÏµúÍ∑º (${latestDateStr || '-'})</th><th>Ï¥ù Î≥ÄÌôîÎüâ</th></tr></thead><tbody>`;
        for (const key of displayKeysInOrder) {
            if (numericKeys.includes(key)) {
                const initialValue = parseFloat(initial[key]);
                const latestValue = parseFloat(latest[key]);
                let change = '-'; let changeClass = '';
                if (isOnlyOneRecord) {
                    change = '-';
                } else if (!isNaN(initialValue) && !isNaN(latestValue)) {
                    const diff = latestValue - initialValue;
                    change = diff.toFixed(1);
                    if (diff > 0.05) { change = `+${change}`; changeClass = 'positive-change'; }
                    else if (diff < -0.05) { changeClass = 'negative-change'; }
                } else if (!isNaN(latestValue) && isNaN(initialValue)) {
                    change = `${formatValue(latestValue)}`;
                    changeClass = ''; // Or positive?
                } else if (isNaN(latestValue) && !isNaN(initialValue)) {
                     change = `-${formatValue(initialValue)}`; // Indicate value loss
                     changeClass = ''; // Or negative?
                }

                tableHTML += `<tr><td>${measurementLabels[key]}</td><td>${formatValue(initialValue)}</td><td>${formatValue(latestValue)}</td><td class="${changeClass}">${change}</td></tr>`;
            }
        }
        tableHTML += '</tbody></table>';
        initialComparisonContainer.innerHTML = tableHTML;
    }

    function renderTargetComparisonTable() {
        if (!targetComparisonContainer) return;
        const targetKeysPresent = numericKeys.some(key => targets[key] !== undefined && targets[key] !== null && targets[key] !== '');
        if (!targetKeysPresent) {
            clearTable(targetComparisonContainer, "ÏÑ§Ï†ïÎêú Î™©ÌëúÍ∞Ä ÏóÜÏñ¥Ïöî."); return;
        }
        if (measurements.length === 0) {
            clearTable(targetComparisonContainer, "Ï∏°Ï†ï Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥Ïöî.");
            return;
        }

        const latestMeasurement = measurements[measurements.length - 1];
        let tableHTML = '<table><thead><tr><th>Ï∏°Ï†ï Ìï≠Î™©</th><th>Î™©Ìëú</th><th>ÌòÑÏû¨</th><th>Îã¨ÏÑ±Î•†</th><th>Ï∞®Ïù¥</th></tr></thead><tbody>';
        for (const key of displayKeysInOrder) {
            // Only show rows where a target exists for that key
            if (numericKeys.includes(key) && targets[key] !== undefined && targets[key] !== null && targets[key] !== '') {
                const targetValue = parseFloat(targets[key]);
                const currentValue = parseFloat(latestMeasurement[key]);
                let difference = '-'; let achievementRate = '-'; let differenceClass = ''; let rateClass = '';

                // Calculate only if target and current values are valid numbers
                if (!isNaN(targetValue) && !isNaN(currentValue)) {
                     // Difference calculation
                     const diff = currentValue - targetValue;
                     difference = diff.toFixed(1);
                     if (diff > 0.05) { difference = `+${difference}`; differenceClass = 'positive-change'; }
                     else if (diff < -0.05) { differenceClass = 'negative-change'; }
                     else { differenceClass = 'target-achieved'; } // Very close or exact

                     // Achievement rate calculation (only if target is positive)
                     if (targetValue > 0) {
                        const rate = (currentValue / targetValue) * 100;
                        achievementRate = `${rate.toFixed(0)}%`;
                        // Rate class based on percentage
                        if (rate >= 100) rateClass = 'target-achieved';
                        else if (rate >= 80) rateClass = 'positive-change';
                        else rateClass = 'negative-change';
                    } else { // Handle targetValue being 0 or negative (rate calculation invalid)
                         achievementRate = '-';
                         rateClass = '';
                         // If target is 0 and current is 0, maybe 'achieved'?
                         if (targetValue === 0 && currentValue === 0) {
                             differenceClass = 'target-achieved';
                             rateClass = 'target-achieved';
                         }
                    }

                } else if (!isNaN(targetValue) && isNaN(currentValue)) { // Target set, but no current value
                    difference = `-${formatValue(targetValue)}`; // Show how much is missing
                    achievementRate = '0%';
                    rateClass = 'negative-change';
                    differenceClass = 'negative-change';
                } else { // Target not a number or current value missing etc.
                     difference = '-';
                     achievementRate = '-';
                }


                tableHTML += `<tr>
                                <td>${measurementLabels[key]}</td>
                                <td>${formatValue(targetValue)}</td>
                                <td>${formatValue(currentValue)}</td>
                                <td class="${rateClass}">${achievementRate}</td>
                                <td class="${differenceClass}">${difference}</td>
                               </tr>`;
            }
        }
        tableHTML += '</tbody></table>';
        targetComparisonContainer.innerHTML = tableHTML;
    }

    function renderCalendarView() {
        console.log("DEBUG: -> renderCalendarView Ìò∏Ï∂úÎê®");
        if (!calendarViewMeasurementList || !countdownDisplay) {
            console.error("DEBUG: [Ïò§Î•ò!] Calendar view elements missing.");
            return;
        }
        if (measurements.length === 0) {
            clearCalendarView();
            countdownDisplay.innerHTML = '<p>Ï∏°Ï†ï Í∏∞Î°ùÏù¥ ÏóÜÏñ¥Ïöî.</p>';
            return;
        }

        try {
            // Extract dates, ensuring they are valid Date objects
            const dateList = measurements.map(m => {
                 let date = null;
                 const dateStr = m.date || m.timestamp;
                 if (dateStr) {
                    if (typeof dateStr === 'number') { // Handle timestamps
                         date = new Date(dateStr);
                    } else if (typeof dateStr === 'string') {
                        // Try parsing YYYY.MM.DD format first
                        const parts = dateStr.match(/(\d{4})\.*? *(\d{1,2})\.*? *(\d{1,2})\.?/);
                        if (parts) {
                            date = new Date(parseInt(parts[1]), parseInt(parts[2]) - 1, parseInt(parts[3]));
                        } else {
                            // Fallback to standard parsing (might handle ISO strings etc.)
                            date = new Date(dateStr);
                        }
                    }
                 }
                 return date && !isNaN(date.getTime()) ? date : null; // Return only valid dates
            }).filter(date => date !== null); // Filter out invalid/null dates

            if (dateList.length === 0) {
                 clearCalendarView();
                 countdownDisplay.innerHTML = '<p>Ïú†Ìö®Ìïú Ï∏°Ï†ï ÎÇ†ÏßúÍ∞Ä ÏóÜÏñ¥Ïöî.</p>';
                 return;
            }

            dateList.sort((a, b) => a.getTime() - b.getTime()); // Sort dates chronologically

            // Display unique measurement dates in the list
            const uniqueDateStrings = [...new Set(dateList.map(date => date.toLocaleDateString('ko-KR')))];
            let listHTML = '<ul>';
            uniqueDateStrings.forEach(dateStr => {
                 const date = new Date(dateStr); // Re-parse for day of week
                 const dayOfWeek = ['Ïùº', 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†'][date.getDay()];
                 listHTML += `<li>${date.getFullYear()}.${(date.getMonth() + 1).toString().padStart(2,'0')}.${date.getDate().toString().padStart(2,'0')} (${dayOfWeek})</li>`;
             });
            listHTML += '</ul>';
            calendarViewMeasurementList.innerHTML = listHTML;

            // Countdown logic based on the latest valid date
            const lastDate = dateList[dateList.length - 1];
            const nextDate = new Date(lastDate.getTime());
            nextDate.setDate(lastDate.getDate() + 7); // Calculate next measurement date (7 days later)

            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize today to the start of the day

            const timeDiff = nextDate.getTime() - today.getTime();
            const daysRemaining = Math.ceil(timeDiff / (1000 * 60 * 60 * 24)); // Calculate remaining days

            const nextDateStr = `${nextDate.getFullYear()}.${(nextDate.getMonth() + 1).toString().padStart(2,'0')}.${nextDate.getDate().toString().padStart(2,'0')}`;
            if (daysRemaining > 1) {
                countdownDisplay.innerHTML = `<p>Îã§Ïùå Ï∏°Ï†ï ÏòàÏ†ïÏùº: <strong>${nextDateStr}</strong> (${daysRemaining}Ïùº ÎÇ®Ïùå)</p>`;
            } else if (daysRemaining === 1) {
                countdownDisplay.innerHTML = `<p>Îã§Ïùå Ï∏°Ï†ï ÏòàÏ†ïÏùº: <strong>${nextDateStr}</strong> (ÎÇ¥Ïùº!)</p>`;
            } else if (daysRemaining === 0) {
                countdownDisplay.innerHTML = `<p><strong>Ïò§ÎäòÏùÄ Ï∏°Ï†ïÌïòÎäî ÎÇ†ÏûÖÎãàÎã§! (${nextDateStr})</strong> üí™</p>`;
            } else { // Measurement day has passed
                countdownDisplay.innerHTML = `<p>Ï∏°Ï†ïÏùº(${nextDateStr})Ïù¥ ${Math.abs(daysRemaining)}Ïùº ÏßÄÎÇ¨Ïñ¥Ïöî. üò• Ïñ¥ÏÑú Í∏∞Î°ùÌïòÏÑ∏Ïöî!</p>`;
            }

            console.log("DEBUG: <- renderCalendarView ÏôÑÎ£å");
        } catch (e) {
            console.error(" renderCalendarView Ïò§Î•ò:", e);
            calendarViewMeasurementList.innerHTML = '<p style="color: red;">Îã¨Î†• Î≥¥Í∏∞ Î†åÎçîÎßÅ Ïò§Î•ò</p>';
            countdownDisplay.innerHTML = '<p style="color: red;">Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Î†åÎçîÎßÅ Ïò§Î•ò</p>';
        }
    }

    function renderChartSelector() {
        console.log("DEBUG: -> renderChartSelector Ìò∏Ï∂úÎê®");
        if (!chartSelector) { console.error("DEBUG: chartSelector ÏóÜÏùå!"); return; }
        try {
            chartSelector.innerHTML = '';
            const selectableKeys = [...numericKeys]; // All numeric keys are selectable
            selectableKeys.forEach(key => {
                const btn = document.createElement('button');
                btn.textContent = measurementLabels[key] || key;
                btn.dataset.metric = key;
                if (selectedMetrics.includes(key)) {
                   btn.classList.add('active');
                }
                chartSelector.appendChild(btn);
            });
            console.log("DEBUG: <- renderChartSelector ÏôÑÎ£å");
        } catch (e) {
            console.error(" Ï∞®Ìä∏ ÏÑ†ÌÉùÍ∏∞ Î†åÎçîÎßÅ Ïò§Î•ò:", e);
        }
    }

    function handleChartSelectorClick(event) {
        const btn = event.target.closest('button');
        if (!btn || !btn.dataset.metric) return;

        const key = btn.dataset.metric;
        console.log(`DEBUG: Ï∞®Ìä∏ ÏÑ†ÌÉù Î≤ÑÌäº ÌÅ¥Î¶≠: ${key}`);

        const isActive = btn.classList.toggle('active');
        if (isActive) {
            if (!selectedMetrics.includes(key)) {
                selectedMetrics.push(key);
            }
        } else {
            selectedMetrics = selectedMetrics.filter(item => item !== key);
        }
        console.log("DEBUG: ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ï∏°Ï†ï Ìï≠Î™©:", selectedMetrics);
        renderChart();
    }

    function handleSelectAllCharts() {
        console.log("DEBUG: Ï∞®Ìä∏ Ï†ÑÏ≤¥ ÏÑ†ÌÉù");
        selectedMetrics = [...numericKeys]; // Select all numeric keys
        chartSelector.querySelectorAll('button').forEach(btn => {
            if (numericKeys.includes(btn.dataset.metric)) {
                btn.classList.add('active');
            } else {
                // Just in case there are non-numeric buttons somehow
                btn.classList.remove('active');
            }
        });
        renderChart();
    }

    function handleDeselectAllCharts() {
        console.log("DEBUG: Ï∞®Ìä∏ Ï†ÑÏ≤¥ Ìï¥Ï†ú");
        selectedMetrics = [];
        chartSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        renderChart();
    }

    function renderChart() {
        console.log(`DEBUG: renderChart Ìò∏Ï∂úÎê® (ÏÑ†ÌÉù Ìï≠Î™©: ${selectedMetrics.join(', ')})`);
        if (!chartCanvas) { console.error("DEBUG: [Ïò§Î•ò!] chartCanvas ÏóÜÏùå!"); return; }

        const ctx = chartCanvas.getContext('2d');
        if (!ctx) { console.error("Canvas contextÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§."); return; }

        // Destroy existing chart instance before creating a new one
        if (chartInstance) {
            console.log("DEBUG: Í∏∞Ï°¥ Ï∞®Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ Ï†úÍ±∞ ÏãúÎèÑ");
            chartInstance.destroy();
            chartInstance = null;
            console.log("DEBUG: Í∏∞Ï°¥ Ï∞®Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ Ï†úÍ±∞ ÏôÑÎ£å");
        }

        try {
            if (measurements.length === 0 || selectedMetrics.length === 0) {
                console.log("DEBUG: Ï∞®Ìä∏ ÌëúÏãúÌï† Îç∞Ïù¥ÌÑ∞ ÎòêÎäî ÏÑ†ÌÉù Ìï≠Î™© ÏóÜÏùå.");
                clearChart(); // Display placeholder message
                return;
            }

            // Prepare labels using week and formatted date
             const labels = measurements.map((m, i) => {
                 const weekLabel = `${m.week !== undefined ? m.week : i}Ï£ºÏ∞®`;
                 const dateLabel = formatTimestamp(m.date || m.timestamp).split(' ')[0]; // Date only
                 return `${weekLabel}${dateLabel ? ` (${dateLabel})` : ''}`;
             });

             const chartColors = ['#FA58B6', '#7A0BC0', '#FFCAD4', '#87CEFA', '#90EE90', '#FFD700', '#F08080', '#a89cc8', '#DA70D6', '#40E0D0', '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'];

             const datasets = selectedMetrics.map((key, index) => {
                const data = measurements.map(m => {
                    const value = m[key];
                    // Ensure only valid numbers or null are passed to the chart
                    return (value !== undefined && value !== null && value !== '') ? parseFloat(value) : null;
                });
                const color = chartColors[index % chartColors.length];
                return {
                    label: measurementLabels[key] || key,
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '33', // Slightly transparent fill
                    tension: 0.2,
                    pointRadius: 3,
                    pointHoverRadius: 6,
                    fill: false, // Don't fill area under line by default
                    spanGaps: true, // Connect points across null values
                    borderWidth: 2,
                };
             });

            // Chart configuration
            const chartConfig = {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                 },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                         y: {
                            beginAtZero: false, // Don't force Y axis to start at 0
                            ticks: { color: '#a89cc8' },
                            grid: { color: 'rgba(168, 156, 200, 0.2)' }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Ï£ºÏ∞® (ÎÇ†Ïßú)',
                                color: '#FFCAD4'
                             },
                            ticks: {
                                color: '#a89cc8',
                                // Display only week number on ticks for clarity
                                callback: function(value, index, values) {
                                     const label = this.getLabelForValue(value);
                                     return label.split(' ')[0]; // Extract "XÏ£ºÏ∞®" part
                                }
                            },
                            grid: { display: false } // Hide vertical grid lines
                        }
                     },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#a89cc8',
                                boxWidth: 12,
                                padding: 15
                            }
                        },
                         tooltip: {
                            mode: 'index', // Show tooltip for all datasets at that index
                            intersect: false, // Tooltip appears even if not hovering directly over point
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#FFCAD4',
                            bodyColor: '#FFFFFF',
                            callbacks: {
                                // Show full label (Week + Date) in tooltip title
                                title: function(tooltipItems) {
                                     if (tooltipItems.length > 0) {
                                         return tooltipItems[0].label; // Use the full label from chart data
                                    }
                                    return '';
                                },
                                // Optional: format tooltip body values
                                // label: function(context) {
                                //     let label = context.dataset.label || '';
                                //     if (label) { label += ': '; }
                                //     if (context.parsed.y !== null) {
                                //         label += formatValue(context.parsed.y);
                                //     }
                                //     return label;
                                // }
                            }
                        },
                        title: { display: false } // Hide overall chart title (using h3 instead)
                     },
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                }
            };
            chartInstance = new Chart(ctx, chartConfig);
            console.log("DEBUG: ÏÉà Ï∞®Ìä∏ Î†åÎçîÎßÅ ÏôÑÎ£å");
        } catch (e) {
            console.error(" Ï∞®Ìä∏ Î†åÎçîÎßÅ Ïò§Î•ò:", e);
            ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
            ctx.font = "16px sans-serif";
            ctx.fillStyle = "red";
            ctx.textAlign = "center";
            ctx.fillText("Ï∞®Ìä∏Î•º ÌëúÏãúÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.", chartCanvas.width / 2, chartCanvas.height / 2);
        }
    }


    function renderAll() {
        console.log("DEBUG: === renderAll Ìò∏Ï∂úÎê® ===");
        try {
            console.log("DEBUG: ÌòÑÏû¨ measurements:", measurements.length, "Í∞ú / notes:", notes.length, "Í∞ú");
            updateCurrentWeekDisplay();
            renderHistoryTable();
            renderPrevWeekComparisonTable();
            renderInitialComparisonTable();
            renderTargetComparisonTable();
            renderCalendarView();
            renderChartSelector();
            renderNotesList();

            // Only render chart if the chart tab is currently active
            const activeTabContent = document.querySelector('.tab-content[style*="display: block"]');
            const activeTabId = activeTabContent ? activeTabContent.id : null;

            if (activeTabId === 'tab-change-report') {
                console.log("DEBUG: Î≥ÄÌôî Î≥¥Í≥†ÏÑú ÌÉ≠ ÌôúÏÑ±, Ï∞®Ìä∏ Î†åÎçîÎßÅ Î°úÏßÅ Ïã§Ìñâ");
                renderChart();
            } else {
                console.log("DEBUG: Î≥ÄÌôî Î≥¥Í≥†ÏÑú ÌÉ≠ ÎπÑÌôúÏÑ± ÏÉÅÌÉú, Ï∞®Ìä∏ Î†åÎçîÎßÅ Í±¥ÎÑàÎúÄ");
                // Optional: Clear chart if switching away from chart tab to free up memory
                // clearChart();
            }

            console.log("DEBUG: === renderAll ÏôÑÎ£å ===");
        } catch (e) {
            console.error(` renderAll Ïã§Ìñâ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}`, e.stack);
        }
    }


    function handleFormSubmit(event) {
        if (event) event.preventDefault();
        console.log("DEBUG: === handleFormSubmit Ìò∏Ï∂úÎê® ===");
        try {
            const editIndexStr = editIndexInput.value;
            const editIndex = editIndexStr !== '' && !isNaN(editIndexStr) ? parseInt(editIndexStr, 10) : -1;
            const isEditing = editIndex !== -1;
            console.log(`DEBUG: ÏàòÏ†ï Î™®Îìú: ${isEditing}, Ïù∏Îç±Ïä§: ${editIndex}`);

            const currentMeasurement = {};
            let isValid = true;
            let firstInvalidField = null;

            // Populate currentMeasurement from form inputs
            [...numericKeys, ...textKeys].forEach(key => {
                const input = document.getElementById(key);
                if (input) {
                    let value = input.value.trim();
                    if (numericKeys.includes(key)) {
                         if (value !== '') {
                            const numValue = parseFloat(value);
                            // Validate numeric input (must be non-negative)
                            if (isNaN(numValue) || numValue < 0) {
                                isValid = false;
                                if (!firstInvalidField) firstInvalidField = input;
                                console.warn(`DEBUG: Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïà´Ïûê ÏûÖÎ†• (${key}): ${value}`);
                                input.classList.add('invalid-input');
                            } else {
                                currentMeasurement[key] = numValue;
                                input.classList.remove('invalid-input');
                            }
                        } else {
                             currentMeasurement[key] = null; // Treat empty numeric fields as null
                             input.classList.remove('invalid-input');
                        }
                    } else { // Text keys
                        currentMeasurement[key] = value === '' ? null : value; // Treat empty text as null
                    }
                } else {
                    console.warn(`DEBUG: ID '${key}' Ïóê Ìï¥ÎãπÌïòÎäî ÏûÖÎ†• ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
                }
            });

            // If validation fails, alert user and focus invalid field
            if (!isValid) {
                alert("Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïà´Ïûê ÏûÖÎ†•Ïù¥ ÏûàÏäµÎãàÎã§. Îπ®Í∞ÑÏÉâÏúºÎ°ú ÌëúÏãúÎêú ÏûÖÎ†• ÌïÑÎìúÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî. Ïà´ÏûêÎäî 0 Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.");
                if(firstInvalidField) firstInvalidField.focus();
                return;
            }

            console.log("DEBUG: Ï†ÄÏû•/ÏàòÏ†ïÎê† Îç∞Ïù¥ÌÑ∞:", currentMeasurement);
            console.log("DEBUG: measurements ÏóÖÎç∞Ïù¥Ìä∏ Ï†Ñ Í∏∏Ïù¥:", measurements.length);

            if (isEditing) {
                // Update existing measurement
                if (editIndex >= 0 && editIndex < measurements.length) {
                    // Preserve existing week and date unless explicitly changed (not possible via form currently)
                    measurements[editIndex] = {
                        ...measurements[editIndex], // Keep existing week, date, etc.
                        ...currentMeasurement      // Overwrite with new form values
                    };
                    console.log(`DEBUG: Ïù∏Îç±Ïä§ ${editIndex} ÏóÖÎç∞Ïù¥Ìä∏Îê®`);
                } else {
                     console.error(`DEBUG: [Ïò§Î•ò!] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏàòÏ†ï Ïù∏Îç±Ïä§: ${editIndex}`);
                     alert("Í∏∞Î°ùÏùÑ ÏàòÏ†ïÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïù∏Îç±Ïä§Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.");
                     return;
                }
            } else {
                // Add new measurement
                currentMeasurement.week = measurements.length; // Assign next week number
                // Assign current date and time (timestamp more reliable)
                currentMeasurement.timestamp = Date.now();
                currentMeasurement.date = new Date().toLocaleDateString('ko-KR', { year: 'numeric', month: '2-digit', day: '2-digit' }); // Also store formatted date string
                measurements.push(currentMeasurement);
                console.log("DEBUG: ÏÉà Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞ÄÎê®");
            }

            console.log("DEBUG: measurements ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ Í∏∏Ïù¥:", measurements.length);
            savePrimaryDataToStorage();
            resetFormState();
            renderAll();
            showPopup(isEditing ? "Ï∏°Ï†ï Í∏∞Î°ù ÏàòÏ†ï ÏôÑÎ£å! ‚ú®" : "Ï∏°Ï†ï Í∏∞Î°ù Ï†ÄÏû• ÏôÑÎ£å! üéâ");
            console.log("DEBUG: === handleFormSubmit ÏÑ±Í≥µ ===");

        } catch (e) {
            console.error(" handleFormSubmit Ïò§Î•ò:", e);
            alert(`Ï∏°Ï†ï Í∏∞Î°ùÏùÑ Ï†ÄÏû•/ÏàòÏ†ïÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${e.message}`);
        }
    }

    function handleDeleteMeasurement(index) {
        if (index === undefined || index === null || index < 0 || index >= measurements.length) {
            console.error(`DEBUG: [Ïò§Î•ò!] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏÇ≠Ï†ú Ïù∏Îç±Ïä§: ${index}`);
            alert("ÏÇ≠Ï†úÌï† Í∏∞Î°ùÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }

        const entryToDelete = measurements[index];
        const displayDate = formatTimestamp(entryToDelete.date || entryToDelete.timestamp).split(' ')[0]; // Date only
        if (confirm(`${entryToDelete.week}Ï£ºÏ∞® (${displayDate}) Í∏∞Î°ùÏùÑ Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.`)) {
            try {
                measurements.splice(index, 1);
                // Re-index subsequent entries
                measurements.forEach((entry, i) => {
                    entry.week = i;
                });
                savePrimaryDataToStorage();
                renderAll();
                resetFormState(); // Clear form if deleted entry was being edited
                showPopup("Ï∏°Ï†ï Í∏∞Î°ù ÏÇ≠Ï†ú ÏôÑÎ£å üëç");
                console.log(`DEBUG: Ïù∏Îç±Ïä§ ${index} Í∏∞Î°ù ÏÇ≠Ï†ú Î∞è Ï£ºÏ∞® Ïû¨Ï†ïÎ†¨ ÏôÑÎ£å`);
            } catch (e) {
                 console.error(` Ïù∏Îç±Ïä§ ${index} ÏÇ≠Ï†ú Ï§ë Ïò§Î•ò:`, e);
                 alert("Í∏∞Î°ù ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
            }
        }
    }

    function handleEditClick(index) {
        if (index === undefined || index === null || index < 0 || index >= measurements.length) {
            console.error(`DEBUG: [Ïò§Î•ò!] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏàòÏ†ï Ïù∏Îç±Ïä§: ${index}`);
            alert("ÏàòÏ†ïÌï† Í∏∞Î°ùÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }
        console.log(`DEBUG: ÏàòÏ†ï Î≤ÑÌäº ÌÅ¥Î¶≠: Ïù∏Îç±Ïä§ ${index}`);
        const entry = measurements[index];

        // Populate form with data from the selected entry
        [...numericKeys, ...textKeys].forEach(key => {
             const input = document.getElementById(key);
             if (input) {
                 input.value = entry[key] !== undefined && entry[key] !== null ? entry[key] : '';
                 input.classList.remove('invalid-input'); // Clear validation state
             }
        });

        // Set form state to editing mode
        editIndexInput.value = index;
        formTitle.textContent = `Ï∏°Ï†ï Í∏∞Î°ù ÏàòÏ†ï (${entry.week}Ï£ºÏ∞®)`;
        saveUpdateBtn.textContent = 'ÏàòÏ†ï ÏôÑÎ£å';
        if (cancelEditBtn) cancelEditBtn.style.display = 'inline-block';

        // Switch to input tab and scroll form into view
        const inputTabButton = tabBar ? tabBar.querySelector('button[data-tab="tab-input"]') : null;
        if (inputTabButton) {
            inputTabButton.click(); // Activate the input tab
            // Use setTimeout to ensure tab content is visible before scrolling
            setTimeout(() => {
                 if (form) form.scrollIntoView({ behavior: 'smooth', block: 'start' });
                 // Optional: focus first input field
                 const firstInput = form.querySelector('input[type="number"], input[type="text"], textarea');
                 if (firstInput) firstInput.focus();
             }, 100);
        }
    }

    function cancelEdit() {
        console.log("DEBUG: ÏàòÏ†ï Ï∑®ÏÜå");
        resetFormState();
    }

    function resetFormState() {
        console.log("DEBUG: Ìèº ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî");
        if (form) form.reset(); // Reset form fields
        editIndexInput.value = ''; // Clear edit index (use empty string for hidden input)
        formTitle.textContent = `ÏÉà Ï∏°Ï†ï Í∏∞Î°ù (ÌòÑÏû¨ ${measurements.length}Ï£ºÏ∞®)`; // Update title
        saveUpdateBtn.textContent = 'Í∏∞Î°ùÌïòÍ∏∞ ‚ú®'; // Reset button text
        if (cancelEditBtn) cancelEditBtn.style.display = 'none'; // Hide cancel button
        // Clear validation states
        [...numericKeys, ...textKeys].forEach(key => {
             const input = document.getElementById(key);
             if (input) {
                 input.classList.remove('invalid-input');
             }
        });
        console.log("DEBUG: Ìèº ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");
    }

    function handleTargetFormSubmit(event) {
        event.preventDefault();
        console.log("DEBUG: === handleTargetFormSubmit Ìò∏Ï∂úÎê® ===");
        const newTargets = {};
        let isValid = true;
        let firstInvalidField = null;
        numericKeys.forEach(key => {
            const input = document.getElementById(`target_${key}`);
            if (input) {
                const value = input.value.trim();
                if (value !== '') {
                    const numValue = parseFloat(value);
                    // Validate target value (must be non-negative)
                     if (isNaN(numValue) || numValue < 0) {
                        isValid = false;
                         if (!firstInvalidField) firstInvalidField = input;
                        input.classList.add('invalid-input');
                        console.warn(`DEBUG: Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Î™©Ìëú Í∞í (${key}): ${value}`);
                    } else {
                        newTargets[key] = numValue;
                         input.classList.remove('invalid-input');
                    }
                } else {
                    newTargets[key] = null; // Treat empty target as null (or undefined?)
                    input.classList.remove('invalid-input');
                }
            }
        });

        if (!isValid) {
            alert("Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Î™©Ìëú Í∞íÏù¥ ÏûàÏäµÎãàÎã§. Îπ®Í∞ÑÏÉâÏúºÎ°ú ÌëúÏãúÎêú ÌïÑÎìúÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî. Î™©Ìëú Í∞íÏùÄ 0 Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.");
            if(firstInvalidField) firstInvalidField.focus();
            return;
        }

        targets = newTargets; // Update targets object
        savePrimaryDataToStorage(); // Save updated targets
        renderAll(); // Re-render tables (especially target comparison)
        showPopup("Î™©Ìëú Ï†ÄÏû• ÏôÑÎ£å! üëç");
        console.log("DEBUG: Î™©Ìëú Ï†ÄÏû• ÏôÑÎ£å:", targets);
    }

    function handleResetData() {
        if (confirm("Ï†ïÎßêÎ°ú Î™®Îì† Ï∏°Ï†ï Í∏∞Î°ù, Î™©Ìëú, Î©îÎ™®Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§!")) {
            if (confirm("Îã§Ïãú Ìïú Î≤à ÌôïÏù∏Ìï©ÎãàÎã§. Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ÏÇ≠Ï†úÎê©ÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) {
                try {
                    localStorage.removeItem(PRIMARY_DATA_KEY); // Clear storage
                    // Reset in-memory state
                    measurements = [];
                    targets = {};
                    notes = [];
                    selectedMetrics = ['weight']; // Reset chart selection
                    currentNoteSortOrder = 'newest'; // Reset note sort order

                    resetFormState(); // Reset input form
                    handleCancelEditNote(); // Reset note form

                    populateTargetInputs(); // Clear target inputs
                    renderAll(); // Re-render everything (will show empty states)
                    showPopup("Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§. ‚ú®");
                    console.log("DEBUG: Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");
                } catch (e) {
                    console.error(" Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•ò Î∞úÏÉù:", e);
                    alert("Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
                }
            }
        }
    }


    function handleSaveNote() {
        console.log("DEBUG: === handleSaveNote Ìò∏Ï∂úÎê® ===");
        if (!noteTitleInput || !noteContentInput || !editNoteIdInput || !noteFormTitle || !saveNoteButton || !cancelEditNoteBtn) {
            console.error("DEBUG: [Ïò§Î•ò!] Î©îÎ™® Í¥ÄÎ†® DOM ÏöîÏÜåÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }

        const title = noteTitleInput.value.trim();
        const content = noteContentInput.value.trim();
        const editingNoteIdStr = editNoteIdInput.value;
        const editingNoteId = editingNoteIdStr ? parseInt(editingNoteIdStr, 10) : null;

        if (!title && !content) {
            alert("Î©îÎ™® Ï†úÎ™©Ïù¥ÎÇò ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî!");
            noteContentInput.focus();
            return;
        }

        try {
            if (editingNoteId !== null && !isNaN(editingNoteId)) {
                // Edit existing note
                const noteIndex = notes.findIndex(n => n.id === editingNoteId);
                if (noteIndex > -1) {
                    notes[noteIndex].title = title || "Ï†úÎ™© ÏóÜÏùå"; // Use default if title empty
                    notes[noteIndex].content = content;
                    notes[noteIndex].updatedAt = Date.now(); // Update timestamp
                    console.log(`DEBUG: Î©îÎ™® ÏàòÏ†ï ÏôÑÎ£å (ID: ${editingNoteId})`);
                } else {
                    console.error(`DEBUG: [Ïò§Î•ò!] ÏàòÏ†ïÌï† Î©îÎ™®Î•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§ (ID: ${editingNoteId})`);
                    alert("Î©îÎ™®Î•º ÏàòÏ†ïÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ìï¥Îãπ Î©îÎ™®Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
                    handleCancelEditNote(); // Reset form if note not found
                    return;
                }
            } else {
                // Add new note
                const newNote = {
                    id: Date.now(), // Use timestamp as unique ID
                    createdAt: Date.now(),
                    updatedAt: null, // No update yet
                    title: title || "Ï†úÎ™© ÏóÜÏùå",
                    content: content
                };
                notes.push(newNote);
                console.log(`DEBUG: ÏÉà Î©îÎ™® Ï∂îÍ∞Ä ÏôÑÎ£å (ID: ${newNote.id})`);
            }

            savePrimaryDataToStorage();
            handleCancelEditNote(); // Reset form after save/edit
            renderNotesList(); // Update note list display
            showPopup(editingNoteId ? "Î©îÎ™® ÏàòÏ†ï ÏôÑÎ£å! ‚ú®" : "ÏÉà Î©îÎ™® Ï†ÄÏû• ÏôÑÎ£å! üéâ");
        } catch (e) {
            console.error(" Î©îÎ™® Ï†ÄÏû•/ÏàòÏ†ï Ïò§Î•ò:", e);
            alert(`Î©îÎ™®Î•º Ï†ÄÏû•ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${e.message}`);
        }
    }

    function handleEditNoteStart(noteId) {
        console.log(`DEBUG: Î©îÎ™® ÏàòÏ†ï ÏãúÏûë: ID ${noteId}`);
        if (!noteTitleInput || !noteContentInput || !editNoteIdInput || !noteFormTitle || !saveNoteButton || !cancelEditNoteBtn) {
             console.error("DEBUG: [Ïò§Î•ò!] Î©îÎ™® ÏàòÏ†ï ÏãúÏûë ÏúÑÌïú DOM ÏöîÏÜå ÎàÑÎùΩ");
             return;
        }
        const note = notes.find(n => n.id === noteId);
        if (!note) {
            console.error(`DEBUG: [Ïò§Î•ò!] ÏàòÏ†ïÌï† Î©îÎ™® Ï∞æÍ∏∞ Ïã§Ìå® (ID: ${noteId})`);
            alert("ÏàòÏ†ïÌï† Î©îÎ™®Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }

        // Populate note form
        noteTitleInput.value = note.title === "Ï†úÎ™© ÏóÜÏùå" ? "" : note.title; // Don't show "Ï†úÎ™© ÏóÜÏùå" in input
        noteContentInput.value = note.content;
        editNoteIdInput.value = note.id; // Set hidden input with note ID

        // Update form UI for editing state
        noteFormTitle.textContent = 'Î©îÎ™® ÏàòÏ†ïÌïòÍ∏∞';
        saveNoteButton.textContent = 'ÏàòÏ†ï ÏôÑÎ£å';
        cancelEditNoteBtn.style.display = 'inline-block'; // Show cancel button

        // Scroll form into view and focus
        if (noteFormArea) {
            noteFormArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
            setTimeout(() => noteTitleInput.focus(), 300); // Focus after scroll animation
        }
    }

    function handleCancelEditNote() {
        console.log("DEBUG: Î©îÎ™® ÏàòÏ†ï/ÏûëÏÑ± Ï∑®ÏÜå");
        if (!noteTitleInput || !noteContentInput || !editNoteIdInput || !noteFormTitle || !saveNoteButton || !cancelEditNoteBtn) {
             console.error("DEBUG: [Ïò§Î•ò!] Î©îÎ™® Ìèº Ï¥àÍ∏∞Ìôî ÏúÑÌïú DOM ÏöîÏÜå ÎàÑÎùΩ");
             return;
         }
        // Reset form fields
        noteTitleInput.value = '';
        noteContentInput.value = '';
        editNoteIdInput.value = ''; // Clear hidden ID input

        // Reset form UI to default state
        noteFormTitle.textContent = 'ÏÉà Î©îÎ™® ÏûëÏÑ±ÌïòÍ∏∞';
        saveNoteButton.textContent = 'Î©îÎ™® Ï†ÄÏû•';
        cancelEditNoteBtn.style.display = 'none'; // Hide cancel button
        console.log("DEBUG: Î©îÎ™® Ìèº Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");
    }

    function handleDeleteNote(noteId) {
        console.log(`DEBUG: Î©îÎ™® ÏÇ≠Ï†ú ÏãúÎèÑ: ID ${noteId}`);
        const noteIndex = notes.findIndex(n => n.id === noteId);
        if (noteIndex < 0) {
            console.error(`DEBUG: [Ïò§Î•ò!] ÏÇ≠Ï†úÌï† Î©îÎ™® Ï∞æÍ∏∞ Ïã§Ìå® (ID: ${noteId})`);
            alert("ÏÇ≠Ï†úÌï† Î©îÎ™®Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }

        const noteTitle = notes[noteIndex].title;
        if (confirm(`"${noteTitle}" Î©îÎ™®Î•º Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.`)) {
            try {
                 notes.splice(noteIndex, 1); // Remove note from array
                 savePrimaryDataToStorage();
                 renderNotesList(); // Update list display
                 showPopup("Î©îÎ™® ÏÇ≠Ï†ú ÏôÑÎ£å üëç");
                 console.log(`DEBUG: Î©îÎ™® ÏÇ≠Ï†ú ÏôÑÎ£å (ID: ${noteId})`);
                 // If the deleted note was being edited, reset the form
                 if (editNoteIdInput.value && parseInt(editNoteIdInput.value, 10) === noteId) {
                     handleCancelEditNote();
                 }
            } catch (e) {
                 console.error(` Î©îÎ™® (ID: ${noteId}) ÏÇ≠Ï†ú Ï§ë Ïò§Î•ò:`, e);
                 alert("Î©îÎ™® ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
            }
        }
    }


    function sortNotes(notesArray, order = 'newest') {
        // Create a copy before sorting to avoid modifying the original array directly
        return [...notesArray].sort((a, b) => {
            // Use createdAt timestamp if available, otherwise fallback to id (which is also a timestamp)
            const timeA = a.createdAt || a.id || 0;
            const timeB = b.createdAt || b.id || 0;
            return order === 'newest' ? timeB - timeA : timeA - timeB; // Sort descending for newest, ascending for oldest
        });
    }


    function renderNotesList() {
        console.log("DEBUG: -> renderNotesList Ìò∏Ï∂úÎê®, Ï†ïÎ†¨:", currentNoteSortOrder);
        if (!notesListContainer) {
             console.error("DEBUG: [Ïò§Î•ò!] notesListContainer ÏöîÏÜå ÏóÜÏùå!");
             return;
        }
        if (!Array.isArray(notes) || notes.length === 0) {
            clearNotesList(); // Show empty message
            return;
        }

        try {
			const sortedNotes = sortNotes(notes, currentNoteSortOrder); // Sort notes based on current selection
			let listHTML = '';
			sortedNotes.forEach(note => {
                // Generate preview text (limit length, handle newlines)
				const previewLength = 100;
				const previewContent = note.content.length > previewLength
					? note.content.substring(0, previewLength).replace(/\n/g, ' ') + '...'
					: note.content.replace(/\n/g, ' ');

                // Format timestamps
                const createdStr = formatTimestamp(note.createdAt || note.id);
                const updatedStr = note.updatedAt ? formatTimestamp(note.updatedAt) : '';

				listHTML += `
				<div class="note-item" data-note-id="${note.id}">
					<h4>${note.title}</h4>
					<div class="note-date">
						ÏûëÏÑ±: ${createdStr}
						${updatedStr ? `<span class="note-updated">(ÏàòÏ†ï: ${updatedStr})</span>` : ''}
					</div>
					<div class="note-content-preview">${previewContent || '(ÎÇ¥Ïö© ÏóÜÏùå)'}</div>
					<div class="note-actions">
						<button class="btn btn-note-edit" data-id="${note.id}">ÏàòÏ†ï</button>
						<button class="btn btn-note-delete" data-id="${note.id}">ÏÇ≠Ï†ú</button>
					</div>
                </div>`;
            });
            notesListContainer.innerHTML = listHTML;
            console.log("DEBUG: <- renderNotesList ÏôÑÎ£å");
        } catch (e) {
            console.error(" Î©îÎ™® Î™©Î°ù Î†åÎçîÎßÅ Ïò§Î•ò:", e);
            notesListContainer.innerHTML = '<p style="color: red;">Î©îÎ™® Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.</p>';
        }
    }

    // ----- Ïä§ÌÅ¨Î°§ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï Ìï®Ïàò ÏãúÏûë -----
    function setupScrollListener() {
        // Ïä§ÌÅ¨Î°§ Î¶¨Ïä§ÎÑà ÎÇ¥Î∂ÄÏóêÏÑú ÏÇ¨Ïö©Ìï† tabBar ÏöîÏÜåÎ•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
        const localTabBar = document.querySelector('.tab-bar'); // Use local variable to avoid potential scope issues if tabBar isn't available globally yet
        if (!localTabBar) {
            console.warn("DEBUG: [Scroll Listener] Tab bar not found during setup.");
            return; // tabBar ÏóÜÏúºÎ©¥ ÏÑ§Ï†ï Ï§ëÎã®
        }

        const scrollThreshold = window.innerHeight * 0.15; // ÌôîÎ©¥ ÎÜíÏù¥Ïùò 15% (Ï°∞Ï†à Í∞ÄÎä•)
        const nearTopThreshold = 50; // ÌôîÎ©¥ ÏµúÏÉÅÎã®ÏúºÎ°ú Í∞ÑÏ£ºÌï† ÌîΩÏÖÄ Í∞í (Ï°∞Ï†à Í∞ÄÎä•)

        // Ïä§ÌÅ¨Î°§ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
        window.addEventListener('scroll', () => {
            const currentScrollY = window.scrollY;
            // Ïä§ÌÅ¨Î°§ Î∞©Ìñ• Í∞êÏßÄÏóê ÏïΩÍ∞ÑÏùò Î≤ÑÌçºÎ•º Îë† (1px Ïù¥ÏÉÅ ÏõÄÏßÅÏòÄÏùÑ ÎïåÎßå Î∞©Ìñ• Í∞êÏßÄ)
            const scrollDelta = currentScrollY - lastScrollY;
            const isScrollingDown = scrollDelta > 1;
            const isScrollingUp = scrollDelta < -1;

            // --- ÏÉÅÌÉú Î≥ÄÍ≤Ω Î°úÏßÅ ---
            if (isScrollingDown && currentScrollY > scrollThreshold && !isTabBarCollapsed) {
                // [Ï∂ïÏÜå] ÏïÑÎûòÎ°ú Ïä§ÌÅ¨Î°§ & ÏûÑÍ≥ÑÏ†ê ÎÑòÏùå & ÏïÑÏßÅ Ï∂ïÏÜå ÏïàÎê®
                localTabBar.classList.add('collapsed');
                isTabBarCollapsed = true;
                // console.log("DEBUG: Tab bar collapsed"); // ÎîîÎ≤ÑÍ∑∏ ÏôÑÎ£å ÌõÑ Ï£ºÏÑù Ï≤òÎ¶¨ Í∞ÄÎä•
            } else if (isScrollingUp && currentScrollY <= scrollThreshold && isTabBarCollapsed) {
                // [ÌôïÏû•] ÏúÑÎ°ú Ïä§ÌÅ¨Î°§ & ÏûÑÍ≥ÑÏ†ê Ïù¥Ìïò & ÌòÑÏû¨ Ï∂ïÏÜåÎê®
                localTabBar.classList.remove('collapsed');
                isTabBarCollapsed = false;
                // console.log("DEBUG: Tab bar expanded"); // ÎîîÎ≤ÑÍ∑∏ ÏôÑÎ£å ÌõÑ Ï£ºÏÑù Ï≤òÎ¶¨ Í∞ÄÎä•
            } else if (currentScrollY < nearTopThreshold && isTabBarCollapsed) {
                // [ÌôïÏû•] ÌôîÎ©¥ ÏµúÏÉÅÎã® Í∑ºÏ≤ò & ÌòÑÏû¨ Ï∂ïÏÜåÎê® (Ïä§ÌÅ¨Î°§ Î∞©Ìñ• Î¨¥Í¥Ä)
                localTabBar.classList.remove('collapsed');
                isTabBarCollapsed = false;
                // console.log("DEBUG: Tab bar expanded (near top)"); // ÎîîÎ≤ÑÍ∑∏ ÏôÑÎ£å ÌõÑ Ï£ºÏÑù Ï≤òÎ¶¨ Í∞ÄÎä•
            }
            // --- Î°úÏßÅ ÎÅù ---

            // ÎßàÏßÄÎßâ Ïä§ÌÅ¨Î°§ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ (ÏùòÎØ∏ÏûàÎäî ÏõÄÏßÅÏûÑÏù¥ ÏûàÏùÑ ÎïåÎßå ÎòêÎäî Îß® ÏúÑÎ°ú Í∞îÏùÑ Îïå)
            if (Math.abs(scrollDelta) > 1 || currentScrollY === 0) {
                 lastScrollY = currentScrollY <= 0 ? 0 : currentScrollY;
            }
        }, { passive: true }); // Ïä§ÌÅ¨Î°§ ÏÑ±Îä• Ìñ•ÏÉÅÏùÑ ÏúÑÌï¥ passive ÏòµÏÖò Ï∂îÍ∞Ä

        console.log("DEBUG: Ïä§ÌÅ¨Î°§ Í∏∞Î∞ò ÌÉ≠ Î∞î Ïà®ÍπÄ Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê® (ÏàòÏ†ïÎê®)");
    }
    // ----- Ïä§ÌÅ¨Î°§ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï Ìï®Ïàò ÎÅù -----


    console.log("DEBUG: Ìï®Ïàò Ï†ïÏùò ÏôÑÎ£å");


    // ===============================================
    // Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï¥àÍ∏∞Ìôî (Initialization)
    // ===============================================
    console.log("DEBUG: Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï¥àÍ∏∞Ìôî ÏãúÏûë");
    try {
        loadAllData(); // Load data from storage first
        setupTargetInputs(); // Setup target form structure
        populateTargetInputs(); // Fill target form with loaded data

        // Activate the first tab by default
        const initialTab = tabBar ? tabBar.querySelector('.tab-button') : null;
        if (initialTab) {
             initialTab.click(); // Simulate click on the first tab button
        } else if (tabContents.length > 0) {
            // Fallback if no tab bar: show first content section
            tabContents.forEach((content, index) => {
                 content.style.display = index === 0 ? 'block' : 'none';
            });
        }

        renderAll(); // Initial render of all components

        console.log("DEBUG: Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");
    } catch (initError) {
        console.error(" Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï¥àÍ∏∞Ìôî Ï§ë Ïã¨Í∞ÅÌïú Ïò§Î•ò Î∞úÏÉù:", initError);
        alert("Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ Ï¥àÍ∏∞ÌôîÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®ÌïòÍ±∞ÎÇò Îç∞Ïù¥ÌÑ∞Î•º Ï¥àÍ∏∞ÌôîÌï¥Ïïº Ìï† Ïàò ÏûàÏäµÎãàÎã§.");
    }

    // ===============================================
    // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï (Event Listener Setup)
    // ===============================================
    console.log("DEBUG: Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï ÏãúÏûë");
    try {
        // Tab Bar Navigation
        if (tabBar) {
            console.log("DEBUG: tabBar Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä");
            tabBar.addEventListener('click', (e) => {
                const button = e.target.closest('.tab-button');
                if (button && button.dataset.tab) {
                    const targetTabId = button.dataset.tab;
                    console.log(`DEBUG: ÌÉ≠ Î≤ÑÌäº ÌÅ¥Î¶≠Îê®: ${targetTabId}`);
                    try {
                        // Deactivate all buttons and content
                        tabBar.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                        tabContents.forEach(content => content.style.display = 'none');

                        // Activate clicked button and corresponding content
                        button.classList.add('active');
                        const targetContent = document.getElementById(targetTabId);
                        if (targetContent) {
                            targetContent.style.display = 'block';
                            console.log(`DEBUG: ${targetTabId} ÌôúÏÑ±Ìôî ÏôÑÎ£å`);

                             // Special actions for specific tabs when activated
                             if (targetTabId === 'tab-change-report') {
                                console.log("DEBUG: Î≥ÄÌôî Î≥¥Í≥†ÏÑú ÌÉ≠ ÌôúÏÑ±Ìôî, Ï∞®Ìä∏ Î†åÎçîÎßÅ");
                                renderChart(); // Render chart specifically when this tab is shown
                            } else if (targetTabId === 'tab-overview') {
                                console.log("DEBUG: Í∞úÏöî ÌÉ≠ ÌôúÏÑ±Ìôî, Î©îÎ™® Î™©Î°ù Î†åÎçîÎßÅ");
                                renderNotesList(); // Re-render notes when this tab is shown
                            } else if (targetTabId === 'tab-calendar') {
                                 renderCalendarView(); // Re-render calendar view when shown
                            } else if (targetTabId === 'tab-history') {
                                 renderHistoryTable(); // Re-render history table when shown
                            }

                        } else {
                             console.error(`DEBUG: [Ïò§Î•ò!] ID '${targetTabId}' Ïóê Ìï¥ÎãπÌïòÎäî ÌÉ≠ Ïª®ÌÖêÏ∏† ÏóÜÏùå!`);
                        }
                    } catch (tabSwitchError) {
                        console.error(" ÌÉ≠ Ï†ÑÌôò Ï§ë Ïò§Î•ò:", tabSwitchError);
                    }
                }
            });
        } else { console.error("DEBUG: [Ïò§Î•ò!] tabBar ÏöîÏÜå ÏóÜÏùå!"); }

        // Measurement Form Submit
        if (form) {
            form.addEventListener('submit', handleFormSubmit);
            console.log("DEBUG: Ï∏°Ï†ï Í∏∞Î°ù Ìèº Ï†úÏ∂ú Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        } else { console.error("DEBUG: [Ïò§Î•ò!] Ï∏°Ï†ï Í∏∞Î°ù Ìèº ÏóÜÏùå!"); }

        // Cancel Edit Measurement Button
        if (cancelEditBtn) {
            cancelEditBtn.addEventListener('click', cancelEdit);
            console.log("DEBUG: Ï∏°Ï†ï ÏàòÏ†ï Ï∑®ÏÜå Î≤ÑÌäº Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }

        // Target Form Submit
        if (targetForm) {
            targetForm.addEventListener('submit', handleTargetFormSubmit);
            console.log("DEBUG: Î™©Ìëú Ìèº Ï†úÏ∂ú Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        } else { console.error("DEBUG: [Ïò§Î•ò!] Î™©Ìëú Ìèº ÏóÜÏùå!"); }

        // Reset Data Button
        if (resetDataButton) {
            resetDataButton.addEventListener('click', handleResetData);
            console.log("DEBUG: Îç∞Ïù¥ÌÑ∞ Î¶¨ÏÖã Î≤ÑÌäº Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }

        // Export Data Button
        if (exportDataButton) {
            exportDataButton.addEventListener('click', exportMeasurementData);
            console.log("DEBUG: Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Î≤ÑÌäº Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }

        // Import Data Button & Input
        if (importDataButton && importFileInput) {
            importDataButton.addEventListener('click', () => importFileInput.click()); // Trigger file input click
            console.log("DEBUG: Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Î≤ÑÌäº Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }
        if (importFileInput) {
            importFileInput.addEventListener('change', importMeasurementData); // Handle file selection
            console.log("DEBUG: ÌååÏùº ÏûÖÎ†• Î≥ÄÍ≤Ω Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }

        // History Table Edit/Delete Buttons (Event Delegation)
        if (historyContainer) {
            historyContainer.addEventListener('click', (e) => {
                const editButton = e.target.closest('.btn-edit');
                const deleteButton = e.target.closest('.btn-delete');

                if (editButton && editButton.dataset.index !== undefined) {
                    handleEditClick(parseInt(editButton.dataset.index, 10));
                } else if (deleteButton && deleteButton.dataset.index !== undefined) {
                    handleDeleteMeasurement(parseInt(deleteButton.dataset.index, 10));
                }
            });
            console.log("DEBUG: Ï∏°Ï†ï Í∏∞Î°ù ÌÖåÏù¥Î∏î Ïù¥Î≤§Ìä∏ ÏúÑÏûÑ Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        } else { console.error("DEBUG: [Ïò§Î•ò!] historyContainer ÏöîÏÜå ÏóÜÏùå!"); }

        // Save Note Button
        if (saveNoteButton) {
             saveNoteButton.addEventListener('click', handleSaveNote);
             console.log("DEBUG: Î©îÎ™® Ï†ÄÏû• Î≤ÑÌäº Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        } else { console.error("DEBUG: [Ïò§Î•ò!] Î©îÎ™® Ï†ÄÏû• Î≤ÑÌäº ÏóÜÏùå!"); }

        // Cancel Edit Note Button
        if (cancelEditNoteBtn) {
             cancelEditNoteBtn.addEventListener('click', handleCancelEditNote);
             console.log("DEBUG: Î©îÎ™® ÏàòÏ†ï Ï∑®ÏÜå Î≤ÑÌäº Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }

        // Note Sort Order Select
        if (noteSortOrderSelect) {
             noteSortOrderSelect.addEventListener('change', (e) => {
                 currentNoteSortOrder = e.target.value;
                 console.log(`DEBUG: Î©îÎ™® Ï†ïÎ†¨ ÏàúÏÑú Î≥ÄÍ≤ΩÎê®: ${currentNoteSortOrder}`);
                 renderNotesList(); // Re-render notes with new sort order
             });
             console.log("DEBUG: Î©îÎ™® Ï†ïÎ†¨ ÏàúÏÑú Î≥ÄÍ≤Ω Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }

        // Notes List Edit/Delete Buttons (Event Delegation)
        if (notesListContainer) {
            notesListContainer.addEventListener('click', (e) => {
                const editBtn = e.target.closest('.btn-note-edit');
                const deleteBtn = e.target.closest('.btn-note-delete');

                if (editBtn && editBtn.dataset.id) {
                    handleEditNoteStart(parseInt(editBtn.dataset.id, 10));
                } else if (deleteBtn && deleteBtn.dataset.id) {
                    handleDeleteNote(parseInt(deleteBtn.dataset.id, 10));
                }
            });
            console.log("DEBUG: Î©îÎ™® Î™©Î°ù Ïù¥Î≤§Ìä∏ ÏúÑÏûÑ Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        } else { console.error("DEBUG: [Ïò§Î•ò!] notesListContainer ÏöîÏÜå ÏóÜÏùå!"); }

        // Chart Selector Buttons (Event Delegation)
        if (chartSelector) {
            chartSelector.addEventListener('click', handleChartSelectorClick);
             console.log("DEBUG: Ï∞®Ìä∏ ÏÑ†ÌÉù Î≤ÑÌäº Ïù¥Î≤§Ìä∏ ÏúÑÏûÑ Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        } else { console.error("DEBUG: [Ïò§Î•ò!] chartSelector ÏöîÏÜå ÏóÜÏùå!"); }

        // Chart Bulk Action Buttons
        if (selectAllChartsBtn) {
             selectAllChartsBtn.addEventListener('click', handleSelectAllCharts);
             console.log("DEBUG: Ï∞®Ìä∏ Ï†ÑÏ≤¥ ÏÑ†ÌÉù Î≤ÑÌäº Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }
        if (deselectAllChartsBtn) {
             deselectAllChartsBtn.addEventListener('click', handleDeselectAllCharts);
             console.log("DEBUG: Ï∞®Ìä∏ Ï†ÑÏ≤¥ Ìï¥Ï†ú Î≤ÑÌäº Î¶¨Ïä§ÎÑà Ï∂îÍ∞ÄÎê®");
        }

        // ----- Ïä§ÌÅ¨Î°§ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï Ìï®Ïàò Ìò∏Ï∂ú -----
        setupScrollListener();
        // ----- Ìò∏Ï∂ú ÎÅù -----

        console.log("DEBUG: Î™®Îì† Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï ÏôÑÎ£å (ÎòêÎäî ÏãúÎèÑ)");

    } catch (listenerError) {
        console.error(" Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï Ï§ë Ïò§Î•ò Î∞úÏÉù:", listenerError);
        alert("ÌéòÏù¥ÏßÄ Ïù∏ÌÑ∞ÎûôÏÖò ÏÑ§Ï†ï Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÏùºÎ∂Ä Í∏∞Îä•Ïù¥ ÏûëÎèôÌïòÏßÄ ÏïäÏùÑ Ïàò ÏûàÏäµÎãàÎã§.");
    }

}); // DOMContentLoaded ÎÅù
